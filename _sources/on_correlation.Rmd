---
jupyter:
  jupytext:
    notebook_metadata_filter: all,-language_info
    split_at_heading: true
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.13.7
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# On correlation

In [voxel time courses](voxel_time_courses.Rmd), we ran a correlation between a *prediction* of a signal we would see from a task, and an *actual* voxel time-course.

This is just a reminder about what correlation is, and how to calculate it.

First, let us go back to where we were at the end of the [voxel time courses](voxel_time_courses.Rmd) page.


```{python}
# Our usual set-up
import numpy as np

# Display array values to 4 digits of precision
np.set_printoptions(precision=4, suppress=True)

import matplotlib.pyplot as plt

import nibabel as nib
import nipraxis
```

We get the files we need:

```{python}
# Fetch the image data file.
data_fname = nipraxis.fetch_file('ds114_sub009_t2r1.nii')
# Fetch the condition file.
cond_fname = nipraxis.fetch_file('ds114_sub009_t2r1_cond.txt')
```

Then we load the files to give our image data, and prediction of the neural signal:

```{python}
# Load data, drop first volume (it was an outlier).
img = nib.load(data_fname)
data = img.get_fdata()[..., 1:]
```

```{python}
# Load the neural time course using pre-packaged function
from nipraxis.stimuli import events2neural

neural = events2neural(cond_fname, 2.5, img.shape[-1])
# Drop the first value (it was an outlier)
neural = neural[1:]

plt.plot(neural)
```

Our voxel of interest was that at position 42, 32, 19 in the 3D volume.

```{python}
voxel_time_course = data[42, 32, 19]

# Plot the neural prediction against the data
plt.plot(neural, voxel_time_course, 'o')

# Set the axis limits to give space on left and right
axis = plt.gca()
axis.set_xlim(-0.1, 1.1)
```

The correlation was:

```{python}
# Correlate the neural time course with the voxel time course
correlation = np.corrcoef(neural, voxel_time_course)[0, 1]
correlation
```

But â€” what is correlation?

There are several answers to that question, but we will answer it like this:

> Correlation is what you get when you turn two sequences into z-scores,
> multiply them together, and take the mean.

Turning a sequence into a z-score is:

* Subtracting the mean of the sequence then
* Dividing by the standard deviation.

Let's do that:

```{python}
vtc_mean = np.mean(voxel_time_course)
vtc_std = np.std(voxel_time_course)
vtc_z_scores = (voxel_time_course - vtc_mean) / vtc_std
```

```{python}
neural_mean = np.mean(neural)
neural_std = np.std(neural)
neural_z_scores = (neural - neural_mean) / neural_std
```

Now we multiply them together:

```{python}
multiplied = vtc_z_scores * neural_z_scores
```

and take the mean:

```{python}
correlation_again = np.mean(multiplied)
correlation_again
```

This recalculation is very very close to the original.  And the difference is
so tiny we can put it down to [floating point
error](https://matthew-brett.github.io/teaching/floating_error.html).

```{python}
np.isclose(correlation, correlation_again)
```
